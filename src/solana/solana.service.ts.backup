import { Injectable, Logger, HttpException, OnModuleDestroy } from '@nestjs/common';
import { Connection, PublicKey, SystemProgram, Transaction, sendAndConfirmTransaction, AccountMeta, Keypair, TransactionInstruction } from '@solana/web3.js';
import { BorshInstructionCoder, BorshAccountsCoder } from '@coral-xyz/anchor';
import { readFileSync } from 'fs';
import { join } from 'path';
import BN from 'bn.js';
import axios, { AxiosInstance } from 'axios';
import * as crypto from 'crypto';
import * as path from 'path';

const idlPath = path.resolve(__dirname, '../idl/snzup_subscription.json');
const idl = JSON.parse(readFileSync(idlPath, 'utf8'));

// Helper for reading Vec<Pubkey> from buffer
function readVecPubkeyLE(buf: Buffer, o: number) {
  const len = buf.readUInt32LE(o); o += 4;
  const out: PublicKey[] = [];
  for (let i = 0; i < len; i++) {
    out.push(new PublicKey(buf.slice(o, o + 32)));
    o += 32;
  }
  return { value: out, offset: o };
}

// Legacy layout decoder for deployed program (version=5)
// [disc(8)] version(u8) owner(PK) owners(Vec<PK>) challengeId(u64) fee(u64)
// commission(u8) status(u8) bump(u8) subscribers(Vec<PK>) winnersList(Vec<PK>)
function decodeLegacyState(data: Buffer) {
  let o = 8; // skip discriminator
  const version = data.readUInt8(o); o += 1;
  const owner = new PublicKey(data.slice(o, o + 32)); o += 32;

  const vOwners = readVecPubkeyLE(data, o); const owners = vOwners.value; o = vOwners.offset;

  const challengeId = new BN(data.slice(o, o + 8), 'le'); o += 8;
  const fee = new BN(data.slice(o, o + 8), 'le'); o += 8;

  const commission = data.readUInt8(o); o += 1;
  const status = data.readUInt8(o); o += 1;
  const bump = data.readUInt8(o); o += 1;

  const vSubscribers = readVecPubkeyLE(data, o); const subscribers = vSubscribers.value; o = vSubscribers.offset;
  const vWinnersList = readVecPubkeyLE(data, o); const winnersList = vWinnersList.value; o = vWinnersList.offset;

  return {
    version,
    bump,
    challengeId,
    fee,
    commission,
    status,
    owner,
    treasuryWallet: null, // not in legacy
    owners,
    subscribers,
    winnersList,
  };
}

// ---- Type coercers driven by IDL ----
const MAX_U64 = new BN('18446744073709551615');

function toU64BN(x: string | number | bigint | BN): BN {
  if (BN.isBN(x)) return x as BN;
  
  if (typeof x === 'bigint') {
    return new BN(x.toString(), 10);
  }
  
  if (typeof x === 'number') {
    if (x > Number.MAX_SAFE_INTEGER) {
      throw new Error(`u64 number ${x} exceeds MAX_SAFE_INTEGER, use string instead`);
    }
    return new BN(x.toString(), 10);
  }
  
  if (typeof x === 'string') {
    const s = x.trim().replace(/_/g, ''); // Allow underscores
    if (!/^[0-9]+$/.test(s)) {
      throw new Error('u64 must be a base-10 integer string');
    }
    const bn = new BN(s, 10);
    if (bn.isNeg() || bn.gt(MAX_U64)) {
      throw new Error('u64 out of range');
    }
    return bn;
  }
  
  throw new Error('u64 must be string|bigint|BN');
}
function toU8Number(x: string | number | bigint): number {
  const n = Number(x);
  if (!Number.isFinite(n) || n < 0 || n > 255) throw new Error(`u8 out of range: ${x}`);
  return n | 0;
}
function toPubkey(x: string | PublicKey): PublicKey {
  return x instanceof PublicKey ? x : new PublicKey(x);
}

// Minimal wallet implementation for server-side signing
class ServerWallet {
  constructor(public payer: Keypair) {}
  get publicKey() { return this.payer.publicKey; }
  async signTransaction(tx: any) { tx.partialSign(this.payer); return tx; }
  async signAllTransactions(txs: any[]) { txs.forEach(t => t.partialSign(this.payer)); return txs; }
}

@Injectable()
export class SolanaService implements OnModuleDestroy {
  private readonly logger = new Logger(SolanaService.name);
  
  private static STATE_DISC_UPPER = crypto
    .createHash('sha256')
    .update('account:State')
    .digest()
    .subarray(0, 8);
  
  private static STATE_DISC_LOWER = crypto
    .createHash('sha256')
    .update('account:state')
    .digest()
    .subarray(0, 8);

  private whichDisc(buf: Buffer): 'upper'|'lower'|'unknown' {
    if (buf.subarray(0,8).equals(SolanaService.STATE_DISC_UPPER)) return 'upper';
    if (buf.subarray(0,8).equals(SolanaService.STATE_DISC_LOWER)) return 'lower';
    return 'unknown';
  }
  
  // instance coders + race-safe init
  private ixCoder!: BorshInstructionCoder;
  private accCoder!: BorshAccountsCoder;
  private coderReady = false;
  private coderInit?: Promise<void>;
  
  private readonly http: AxiosInstance;
  private readonly timeout = Number(process.env.BACKEND_TIMEOUT_MS ?? 5000);
  private readonly backendEnabled: boolean;
  private readonly baseURL: string;

  private idl: any;
  private connection: Connection;
  private wallet: ServerWallet;
  private programId: PublicKey;
  private initPromise?: Promise<void>;
  private cachedState?: { pda: PublicKey; layout: 'new' | 'legacy' };

  constructor() {
    // Backend HTTP client (optional)
    this.baseURL = (process.env.MAIN_BACKEND_URL || '').trim();
    this.backendEnabled = this.baseURL.length > 0;
    this.http = axios.create({
      baseURL: this.backendEnabled ? this.baseURL.replace(/\/+$/, '') : 'http://127.0.0.1:9',
      timeout: this.timeout,
      headers: { 'Content-Type': 'application/json' },
    });
    
    // Startup validation: IDL/Program ID consistency
    this.validateProgramId();
    
    // Backend is optional for direct Solana-only operation
    this.http.interceptors.response.use(
      (res: any) => res,
      (err: any) => {
        const status = err.response?.status ?? 503;
        const data = err.response?.data as any;
        const code = data?.code || 'BACKEND_ERROR';
        const message = data?.message || err.message || 'Upstream backend error';
        throw new HttpException({ code, status, message }, status);
      }
    );

    // ---- Solana client setup ----
    const rpc = process.env.SOLANA_RPC_URL;
    const secretKey = process.env.SOLANA_OWNER_SECRET_KEY;
    if (!rpc) throw new HttpException({ code: 'SOLANA_RPC_URL_MISSING', message: 'SOLANA_RPC_URL env is required' }, 503);
    if (!process.env.PROGRAM_ID) throw new HttpException({ code: 'PROGRAM_ID_MISSING', message: 'PROGRAM_ID env is required' }, 503);
    if (!process.env.CHALLENGE_ID) throw new HttpException({ code: 'CHALLENGE_ID_MISSING', message: 'CHALLENGE_ID env is required' }, 503);
    if (!secretKey) throw new HttpException({ code: 'SOLANA_OWNER_SECRET_KEY_MISSING', message: 'SOLANA_OWNER_SECRET_KEY env is required' }, 503);

    try {
      // Handle both JSON array format and file path
      let keypairData: number[];
      if (secretKey.startsWith('[') && secretKey.endsWith(']')) {
        // JSON array format
        keypairData = JSON.parse(secretKey);
      } else if (secretKey.startsWith('/') || secretKey.includes('.json')) {
        // File path format
        const fs = require('fs');
        keypairData = JSON.parse(fs.readFileSync(secretKey, 'utf8'));
      } else {
        throw new Error('Invalid format - must be JSON array or file path');
      }
      this.wallet = new ServerWallet(Keypair.fromSecretKey(Uint8Array.from(keypairData)));
    } catch (err) {
      throw new HttpException({ code: 'INVALID_SECRET_KEY_FORMAT', message: `Invalid SOLANA_OWNER_SECRET_KEY format: ${(err as Error).message}` }, 503);
    }
    this.connection = new Connection(rpc, 'confirmed');
    this.programId = new PublicKey(process.env.PROGRAM_ID);
    this.logger.log(`Solana ready @ ${rpc} | Program=${this.programId.toBase58()}`);
    this.logger.log('Coders (IDL/Accounts/Instruction) will be initialized lazily on first use');
    
    // Validate RPC connection
    this.connection.getLatestBlockhash('confirmed').catch(e => {
      this.logger.error(`RPC connection failed: ${e.message}`);
    });
  }

  private validateProgramId() {
    const envProgramId = process.env.PROGRAM_ID;
    if (!envProgramId) {
      throw new HttpException({ code: 'MISSING_PROGRAM_ID', message: 'PROGRAM_ID environment variable is required' }, 503);
    }
    
    const idlProgramId = idl?.metadata?.address;
    if (idlProgramId && idlProgramId !== envProgramId) {
      throw new HttpException({
        code: 'IDL_PROGRAM_MISMATCH',
        message: `IDL program ID (${idlProgramId}) does not match PROGRAM_ID (${envProgramId})`,
        details: { idlProgramId, envProgramId }
      }, 503);
    }
  }

  private async ensureCoder() {
    if (this.coderReady) return;
    if (!this.coderInit) {
      this.coderInit = (async () => {
        this.logger.log('Creating Borsh coders (once)…');
        
        // Startup validation: IDL program ID must match environment PROGRAM_ID
        const idlProgramId = idl.metadata?.address || idl.address;
        if (!idlProgramId) {
          throw new Error('IDL missing program ID in metadata.address or address field');
        }
        if (idlProgramId !== this.programId.toBase58()) {
          throw new Error(`IDL program ID mismatch: IDL=${idlProgramId}, ENV=${this.programId.toBase58()}`);
        }
        this.logger.log(`✅ IDL program ID validated: ${idlProgramId}`);
        
        this.ixCoder = new BorshInstructionCoder(idl);
        this.accCoder = new BorshAccountsCoder(idl);
        this.coderReady = true;
      })();
    }
    await this.coderInit;
  }

  onModuleDestroy(): void {
    if (this.connection && typeof (this.connection as any)._rpcWebSocket?.close === 'function') {
      try { (this.connection as any)._rpcWebSocket.close(); } catch (e) { /* ignore */ }
    }
  }

  // PDA helper
  private deriveStatePda(owner: PublicKey, challengeId: bigint | number): PublicKey {
    const buf = Buffer.alloc(8);
    buf.writeBigUInt64LE(BigInt(challengeId));
    const [pda] = PublicKey.findProgramAddressSync(
      [Buffer.from('state'), owner.toBuffer(), buf],
      this.programId
    );
    return pda;
  }

  private async getStateAndPda() {
    const pda = this.deriveStatePda(this.wallet.publicKey, BigInt(process.env.CHALLENGE_ID || '1'));
    const info = await this.rpc('getAccountInfo', () => this.connection.getAccountInfo(pda));
    if (!info) this.fail(404, 'STATE_NOT_FOUND', 'State account not found');
    
    // Validate account owner before decoding
    if (!info.owner.equals(this.programId)) {
      this.fail(422, 'INVALID_ACCOUNT_OWNER', `Account owner ${info.owner.toBase58()} does not match program ID ${this.programId.toBase58()}`);
    }
    
    const acc = await this.decodeStateAny(info.data);
    
    // Keep the PDA derived from env as source-of-truth (don't recompute from mutable owner field)
    
    return { state: pda, acc };
  }

  // ---- Backend integration (optional) ----
  private async get(path: string, cfg?: any) {
    if (!this.backendEnabled) return null;
    const res = await this.http.get(path, cfg);
    return res.data;
  }
  private async post(path: string, body?: any, cfg?: any) {
    if (!this.backendEnabled) return { skipped: true };
    const res = await this.http.post(path, body ?? {}, cfg);
    return res.data;
  }


  // Public API (same surface your controller uses)

  async health() {
    if (!this.backendEnabled) return { ok: true, backend: false };
    try { await this.get('/api/health'); return { ok: true, backend: true }; }
    catch { return { ok: true, backend: false }; }
  }
  // Always proxy to backend for automated integration
  async getStateAccount() {
    const { state, acc } = await this.getStateAndPda();
    return {
      pda: state.toBase58(),
      version: acc.version,
      owner: acc.owner.toBase58(),
      owners: acc.owners.map((o: any) => o.toBase58()),
      challengeId: acc.challengeId.toString(),
      fee: acc.fee.toString(),
      commission: acc.commission,
      status: acc.status,
      bump: acc.bump,
      subscribers: acc.subscribers.map((s: any) => s.toBase58()),
      winnersList: acc.winnersList.map((w: any) => w.toBase58()),
      subscribersCount: acc.subscribers.length,
      treasuryWallet: (acc as any).treasuryWallet ? (acc as any).treasuryWallet.toBase58?.() : null,
    };
  }

  async getFee() {
    const { acc } = await this.getStateAndPda();
    return { fee: acc.fee.toString() };
  }

  async getCommission() {
    const { acc } = await this.getStateAndPda();
    return { commission: acc.commission };
  }

  async getWinners() {
    if (this.backendEnabled) return this.get('/api/winners');
    const s = await this.getStateAccount();
    return { winners: s.winnersList };
  }

  async getChallengeId() {
    if (this.backendEnabled) return this.get('/api/challenge-id');
    const s = await this.getStateAccount();
    return { challengeId: s.challengeId };
  }  

  async tx(signature: string) {
    return this.get(`/api/tx/${encodeURIComponent(signature)}`);
  }

  async events(signature: string) {
    return this.get(`/api/tx/${encodeURIComponent(signature)}/events`);
  }

  private findIxOrThrow(name: string) {
    const ix = this.idl.instructions.find((i: any) => i.name === name);
    if (!ix) throw new HttpException({ code: 'IDL_IX_MISSING', status: 500, message: `${name} not found in IDL` }, 500);
    return ix;
  }

  private wantsAccount(ixName: string, accountName: string): boolean {
    const ix = this.findIxOrThrow(ixName);
    return Array.isArray(ix.accounts) && ix.accounts.some((a: any) => a.name === accountName);
  }

  private readU64LE(b: Buffer, o: number) { return new BN(b.subarray(o, o + 8), 'le'); }
  private readPk(b: Buffer, o: number) { return new PublicKey(b.subarray(o, o + 32)); }
  // --- Error & RPC helpers -----------------------------------------------
  private fail(status: number, code: string, message: string, details?: any): never {
    const error = {
      code, status, message, details,
      timestamp: new Date().toISOString(),
      mode: 'online'
    };
    this.logger.error(`${code}: ${message}${details ? ` | ${String(details)}` : ''}`);
    throw new HttpException(error, status);
  }

  private readonly ERRORS_BY_CODE = new Map<number, string>(
    (idl.errors || []).map((e: any) => [e.code, e.name])
  );

  private parseProgramError(e: any) {
    const m = String(e?.message || '').match(/custom program error: 0x([0-9a-f]+)/i);
    if (!m) return null;
    const code = parseInt(m[1], 16);
    return { code, name: this.ERRORS_BY_CODE.get(code) || `CUSTOM_${code}` };
  }

  private async rpc<T>(label: string, fn: () => Promise<T>, attempts = 3): Promise<T> {
    let last: any;
    for (let i = 0; i < attempts; i++) {
      try { return await fn(); }
      catch (e: any) {
        last = e;
        const msg = String(e?.message || '');
        const transient = /429|Too Many|ECONNRESET|ETIMEDOUT|network/i.test(msg);
        if (!transient || i === attempts - 1) break;
        await new Promise(r => setTimeout(r, 200 * (i + 1) + Math.random() * 150));
      }
    }
    throw last;
  }

  private readVecPkSafe(b: Buffer, o: number) {
    const len = b.readUInt32LE(o); o += 4;
    const max = Math.floor((b.length - o) / 32);
    if (len < 0 || len > max) throw new Error(`Bad Vec<Pubkey> length: ${len} (max ${max})`);
    const out: PublicKey[] = new Array(len);
    for (let i = 0; i < len; i++) { out[i] = this.readPk(b, o); o += 32; }
    return { value: out, offset: o };
  }

  private assertVec(arr: any, name: string, max: number) {
    if (!Array.isArray(arr)) this.fail(400, 'BAD_INPUT', `${name} must be array`);
    if (arr.length > max)    this.fail(400, 'BAD_INPUT', `${name} length must be <= ${max}`);
  }

  /** Heuristics to accept a decoded candidate */
  private plausible(s: any): boolean {
    return s && typeof s.version === 'number' && s.version >= 0 && s.version <= 10 &&
           s.challengeId && s.fee && typeof s.commission === 'number' &&
           Array.isArray(s.owners) && Array.isArray(s.subscribers) && Array.isArray(s.winnersList);
  }

  // IDL-first decoder with legacy fallback
  private async decodeStateAny(data: Buffer) {
    // Try IDL decode first (uses whatever name is in fresh IDL)
    try {
      await this.ensureCoder();
      const accountName = (idl.accounts?.[0]?.name) || 'state';
      return this.accCoder.decode(accountName, data); // authoritative
    } catch (e) {
      // Fallback: legacy layout based on observed on-chain header
      const disc = this.whichDisc(data);
      if (disc === 'upper') {
        return this.decodeLegacyState(data);
      }
      // Show useful bytes for debugging instead of generic error
      const head = data.subarray(0, 40).toString('hex');
      this.fail(422, 'STATE_DECODE_FAILED', `Unknown discriminator / layout. Head=${head}`);
    }
  }

  // Legacy decoder for 'account:State' discriminator
  private decodeLegacyState(data: Buffer) {
    if (data.length < 8 + 1 + 1 + 8 + 8 + 1 + 1 + 32) {
      throw new Error('State account too small for header');
    }
    
    let o = 8;
    const version = data.readUInt8(o); o += 1;
    const bump = data.readUInt8(o); o += 1;
    const challengeId = this.readU64LE(data, o); o += 8;
    const fee = this.readU64LE(data, o); o += 8;
    const commission = data.readUInt8(o); o += 1;
    const status = data.readUInt8(o); o += 1;
    const owner = this.readPk(data, o); o += 32;
    
    // Read vectors with hard bounds to prevent heap overflow
    const v1 = this.readVecPkSafe(data, o); const owners = v1.value; o = v1.offset;
    const v2 = this.readVecPkSafe(data, o); const subscribers = v2.value; o = v2.offset;
    const v3 = this.readVecPkSafe(data, o); const winnersList = v3.value;
    
    return { 
      version, 
      bump, 
      challengeId, 
      fee, 
      commission, 
      status, 
      owner, 
      treasuryWallet: null, 
      owners, 
      subscribers, 
      winnersList 
    };
  }


  private async sendIx(ixName: string, keys: any[], args: any): Promise<string> {
    await this.ensureCoder();
    return await this.rpc(`sendIx(${ixName})`, async () => {
      const ixData = this.ixCoder.encode(ixName, args);
      const instruction = new TransactionInstruction({
        programId: this.programId,
        keys,
        data: ixData
      });
      const tx = new Transaction().add(instruction);
      tx.feePayer = this.wallet.publicKey;
      const { blockhash } = await this.connection.getLatestBlockhash('confirmed');
      tx.recentBlockhash = blockhash;
      tx.sign(this.wallet.payer);
      
      try {
        return await sendAndConfirmTransaction(this.connection, tx, [this.wallet.payer], { commitment: 'confirmed' });
      } catch (e: any) {
        const progErr = this.parseProgramError(e);
        if (progErr) {
          this.fail(400, progErr.name, `Program error: ${progErr.name} (${progErr.code})`, { programError: progErr });
        }
        throw e;
      }
    });
  }

  private statePda(): PublicKey {
    const override = (process.env.STATE_PDA || '').trim();
    if (override) return new PublicKey(override);
    const challenge = BigInt(process.env.CHALLENGE_ID!);
    return this.deriveStatePda(this.wallet.publicKey, challenge);
  }

  private async resolveTreasury(acc: any) {
    // new layout has it in state
    if (acc?.treasuryWallet) return new PublicKey(acc.treasuryWallet);
    // legacy: ask backend config
    if (this.backendEnabled) {
      const cfg = await this.get('/api/solana/config');
      const t = (cfg?.treasuryWallet || cfg?.treasury)?.toString().trim();
      if (t) return new PublicKey(t);
    }
    // fallback to env
    const envTreasury = (process.env.TREASURY_PUBKEY || '').trim();
    if (envTreasury) return new PublicKey(envTreasury);
    
    this.fail(500, 'TREASURY_NOT_FOUND', 'Treasury wallet not found in state, backend config, or env');
  }

  async refund(body: { subscribers: string[]; amounts: string[] }) {
    this.assertVec(body.subscribers, 'subscribers', 1000);
    this.assertVec(body.amounts, 'amounts', 1000);
    if (body.subscribers.length !== body.amounts.length) {
      this.fail(400, 'BAD_INPUT', 'subscribers and amounts arrays must have same length');
    }
    
    const { state, acc } = await this.getStateAndPda();
    const treasury = await this.resolveTreasury(acc);
    const subscribers = body.subscribers.map(s => new PublicKey(s));
    const amounts = body.amounts.map(a => toU64BN(a));
    
    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: treasury, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ...subscribers.map(s => ({ pubkey: s, isSigner: false, isWritable: true }))
    ];
    
    const signature = await this.sendIx('refund', keys, { subscribers, amounts });
    if (this.backendEnabled) {
      try { await this.post('/api/refund', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async distribute(body: { winners: string[]; amounts: string[] }) {
    this.assertVec(body.winners, 'winners', 100);
    this.assertVec(body.amounts, 'amounts', 100);
    if (body.winners.length !== body.amounts.length) {
      this.fail(400, 'BAD_INPUT', 'winners and amounts arrays must have same length');
    }
    
    const { state, acc } = await this.getStateAndPda();
    const treasury = await this.resolveTreasury(acc);
    const snoozup = toPubkey(process.env.SNOOZUP_WALLET!);
    const winners = body.winners.map(toPubkey);
    const amounts = body.amounts.map(toU64BN);

    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false }, // authority
      { pubkey: treasury, isSigner: false, isWritable: true },
      { pubkey: snoozup, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ...winners.map(w => ({ pubkey: w, isSigner: false, isWritable: true })),
    ];

    const signature = await this.sendIx('sendBonusToWinners', keys, { snoozupWallet: snoozup });
    if (this.backendEnabled) {
      try { await this.post('/api/distribute', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async withdraw() {
    const { state, acc } = await this.getStateAndPda();
    const treasury = await this.resolveTreasury(acc);
    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
      { pubkey: treasury, isSigner: false, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];
    const signature = await this.sendIx('withdrawFunds', keys, {});
    if (this.backendEnabled) {
      try { await this.post('/api/withdraw-funds', { signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async setWinners(body: { winners: string[] }) {
    this.assertVec(body.winners, 'winners', 100);
    const pda = this.deriveStatePda(this.wallet.publicKey, BigInt(process.env.CHALLENGE_ID || '1'));
    const winners = body.winners.map(w => new PublicKey(w));
    const keys = [
      { pubkey: pda, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false },
    ];
    const signature = await this.sendIx('setWinnersList', keys, { winners });
    if (this.backendEnabled) {
      try { await this.post('/api/set-winners', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async handleWebhook(body: any, headers: any) {
    return { received: true, body, headers };
  }

  async removeOwner(body: { owner: string }) {
    const { state } = await this.getStateAndPda();
    const ownerToRemove = new PublicKey(body.owner);
    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false },
    ];
    const signature = await this.sendIx('removeOwner', keys, { owner: ownerToRemove });
    if (this.backendEnabled) {
      try { await this.post('/api/remove-owner', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async setStatus(body: { status: number }) {
    const { state } = await this.getStateAndPda();
    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false },
    ];
    const signature = await this.sendIx('setStatus', keys, { status: body.status });
    if (this.backendEnabled) {
      try { await this.post('/api/set-status', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async cancelSubscription(body: { subscriber: string }) {
    const { state } = await this.getStateAndPda();
    const subscriber = new PublicKey(body.subscriber);
    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: subscriber, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false },
    ];
    const signature = await this.sendIx('cancelSubscription', keys, { subscriber });
    if (this.backendEnabled) {
      try { await this.post('/api/cancel-subscription', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async setCommission(body: { commissionPercentage: string | number }) {
    const pda = this.deriveStatePda(this.wallet.publicKey, BigInt(process.env.CHALLENGE_ID || '1'));
    const keys = [
      { pubkey: pda, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false },
    ];
    const signature = await this.sendIx('setCommision', keys, { commissionPercentage: toU8Number(body.commissionPercentage) });
    try { await this.post('/api/set-commission', { ...body, signature }); } catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    return { signature };
  }

  async setFee(body: { newFee: string | number }) {
    const pda = this.deriveStatePda(this.wallet.publicKey, BigInt(process.env.CHALLENGE_ID || '1'));
    const keys = [
      { pubkey: pda, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: false },
    ];
    const signature = await this.sendIx('setFee', keys, { fee: toU64BN(body.newFee) });
    if (this.backendEnabled) {
      try { await this.post('/api/set-fee', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async initialize(body: { challengeId: string|number|bigint; fee: string|number|bigint; commission: string|number|bigint; }) {
    const challengeId = toU64BN(body.challengeId);
    const fee = toU64BN(body.fee);
    const commission = toU8Number(body.commission);
    
    if (commission < 0 || commission > 100) {
      this.fail(400, 'BAD_INPUT', 'commission must be 0-100');
    }
    
    // Check if already initialized
    try {
      const state = this.statePda();
      const exists = await this.rpc('getAccountInfo', () => this.connection.getAccountInfo(state, 'confirmed'));
      if (exists) return { alreadyInitialized: true, state: state.toBase58() };
    } catch {
      // Not found, proceed with initialization
    }
    
    const state = this.statePda();
    const keys = [
      { pubkey: state, isSigner: false, isWritable: true },
      { pubkey: this.wallet.publicKey, isSigner: true, isWritable: true },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    ];
    
    const signature = await this.sendIx('initialize', keys, { challengeId, fee, commission });
    if (this.backendEnabled) {
      try { await this.post('/api/initialize', { ...body, signature }); } 
      catch (e) { this.logger.warn(`Backend sync failed: ${(e as Error).message}`); }
    }
    return { signature };
  }

  async ready() {
    try {
      const pda = this.statePda();
      const acc = await this.connection.getAccountInfo(pda, 'confirmed');
      let backendOk = false;
      if (this.backendEnabled) { try { await this.get('/api/health'); backendOk = true; } catch {} }
      return { rpc: true, programLoaded: true, stateExists: !!acc, backend: backendOk };
    } catch (e: any) {
      return { rpc: false, programLoaded: false, stateExists: false, backend: false, error: e?.message };
    }
  }
}
